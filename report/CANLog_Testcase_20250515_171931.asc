if service_int == 0x10:  # DiagnosticSessionControl
    response = client.change_session(subfunc_int)
elif service_int == 0x11:  # ECUReset
    response = client.ecu_reset(subfunc_int)
elif service_int == 0x22:  # ReadDataByIdentifier
    response = client.read_data_by_identifier(subfunc_int)
elif service_int == 0x2E:  # WriteDataByIdentifier
    # Example expects to write the expected_bytes to the DID = subfunc_int
    response = client.write_data_by_identifier(subfunc_int, bytes(expected_bytes))
elif service_int == 0x19:  # ReadDTCInformation
    # Subfunction and optional statusMask used for DTC queries
    # For now only support subfunction with no extra parameters
    response = client.read_dtc_information(subfunc_int)
elif service_int == 0x14:  # ClearDiagnosticInformation
    # subfunc_int may represent groupOfDTC, for simplicity pass it as 3 bytes
    group_of_dtc = subfunc_int.to_bytes(3, byteorder='big')
    response = client.clear_diagnostic_information(group_of_dtc)
elif service_int == 0x3E:  # TesterPresent
    # subfunc_int = 0x00 means "zero suppress" (standard)
    response = client.tester_present(subfunc_int)
else:
    raise ValueError(f"Unsupported service: {service}")
