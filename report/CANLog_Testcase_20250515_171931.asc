if service_int == 0x10:
    response = client.change_session(subfunc_int)
elif service_int == 0x11:
    response = client.ecu_reset(subfunc_int)
elif service_int == 0x22:
    response = client.read_data_by_identifier(subfunc_int)
elif service_int == 0x2E:
    # WriteDataByIdentifier - Needs value to write (provided in 'expected')
    write_value = bytes(expected_bytes)
    response = client.write_data_by_identifier(subfunc_int, write_value)
elif service_int == 0x19:
    # ReadDTCInformation - sub-function as input
    response = client.read_dtc_information(subfunc_int)
elif service_int == 0x14:
    # ClearDiagnosticInformation - No parameters typically needed
    # But some ECUs may expect groupOfDTC
    group_of_dtc = bytes(expected_bytes) if expected_bytes else b'\xFF\xFF\xFF'
    response = client.clear_diagnostic_information(group_of_dtc)
elif service_int == 0x3E:
    # Tester Present – subfunction usually 0x00
    response = client.tester_present(subfunc_int)
elif service_int == 0x85:
    # ControlDTCSetting – typically with subfunction 0x01 = ON, 0x02 = OFF
    response = client.control_dtc_setting(subfunc_int)
elif service_int == 0x27:
    # Security Access
    if subfunc_int % 2 == 1:
        # Request Seed
        response = client.security_access(subfunc_int)
    else:
        # Send Key – needs key from expected
        key = bytes(expected_bytes)
        response = client.security_access(subfunc_int, key=key)
elif service_int == 0x28:
    # Communication Control
    # Usually requires communicationType and optionally controlOptionRecord
    # We'll use subfunc as communicationType, and expected as controlOptionRecord
    control_option = bytes(expected_bytes) if expected_bytes else b''
    response = client.communication_control(subfunc_int, control_option)
else:
    raise ValueError(f"Unsupported service: {service}")




NEW








