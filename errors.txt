import socket
import logging
import time
from datetime import datetime

MAX_RETRIES = 3
TIMEOUT = 5  # seconds

def send_seed_with_retry(seed_hex, udp_ip, udp_port):
    attempt = 0
    while attempt < MAX_RETRIES:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(TIMEOUT)
            sock.sendto(seed_hex.encode(), (udp_ip, udp_port))
            logging.info(f"Attempt {attempt + 1}: Seed sent to {udp_ip}:{udp_port}")
            key, _ = sock.recvfrom(1024)
            logging.info(f"Received Key: {key}")
            return key
        except socket.timeout:
            logging.warning(f"Attempt {attempt + 1}: Timeout waiting for key from PC")
            attempt += 1
            time.sleep(1)  # Optional: wait before retrying
        except Exception as e:
            logging.error(f"Attempt {attempt + 1}: Exception occurred - {e}")
            attempt += 1
            time.sleep(1)  # Optional: wait before retrying
        finally:
            sock.close()
    raise Exception("Failed to receive key after multiple attempts")

def run_testcase(self, oled):
    self.check_memory(oled) 
    self.start_logging(log_name_suffix="Testcase")
    grouped_cases = load_testcases() 
    report_entries = []
   
    run_start = datetime.now()

    start_time = datetime.now()
    first_request_time = None
    last_response_time = None
    
    with Client(self.conn, request_timeout=2, config=self.client_config) as client:
        client.config['p2_timeout'] = 6.0
        for tc_id, steps in grouped_cases.items():
            logging.info(f"Running Test Case: {tc_id}")
            for step in steps:
                _, step_desc, service, subfunc, expected = step
                try:
                    service_int = int(service, 16)
                    subfunc_int = int(subfunc, 16)
                    expected_bytes = [int(b, 16) for b in expected.strip().split()]
                    logging.info(f"{tc_id} - {step_desc}: SID={service}, Sub={subfunc}, Expected={expected_bytes}")

                    request_time = datetime.now()

                    response = None
                    if service_int == 0x10:
                        response = client.change_session(subfunc_int)
                    elif service_int == 0x11:
                        response = client.ecu_reset(subfunc_int)
                    elif service_int == 0x22:
                        response = client.read_data_by_identifier(subfunc_int)
                    elif service_int == 0x2E:  # WriteDataByIdentifier
                        # Implement write_data_by_identifier logic here
                        pass
                    elif service_int == 0x19:  # ReadDTCInformation
                        response = client.read_dtc_information(subfunc_int, status_mask=0xFF)
                    elif service_int == 0x14:  # ClearDiagnosticInformation
                        group_of_dtc = subfunc_int
                        response = client.clear_dtc(group_of_dtc)
                    elif service_int == 0x3E:  # TesterPresent
                        response = client.tester_present()
                    elif service_int == 0x85:
                        response = client.control_dtc_setting(subfunc_int)
                    elif service_int == 0x27: 
                        if subfunc_int == 0x11:  
                            response = client.request_seed(subfunc_int)
                            
                            if not response.positive:
                                failure_reason = f"NRC (seed): {hex(response.code)}"
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                                raise Exception(failure_reason)
                            
                            seed = response.service_data.seed
                            logging.info(f"Received Seed: {seed.hex()}")
                            
                            # Send seed to PC via UDP with retry mechanism
                            udp_ip = "192.168.10.220"  # PC IP address
                            udp_port = 5005  # PC UDP server port
                            
                            try:
                                seed_hex = seed.hex()
                                key = send_seed_with_retry(seed_hex, udp_ip, udp_port)
                            except Exception as e:
                                failure_reason = str(e)
                                logging.error(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                                raise
                            
                            # Send Key
                            key_subfunc = 0x12
                            response = client.send_key(key_subfunc, key)
                            if not response.positive:
                                failure_reason = f"NRC (key): {hex(response.code)}"
                                logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                                raise Exception(failure_reason)
                    elif service_int == 0x28:  # CommunicationControl
                        control_type = subfunc_int  # Subfunction
                        communication_type = 0x00  # Default: Enable Rx and Tx
                        if control_type == 0x00:
                            communication_type = 0x00  # Enable Rx and Tx
                        elif control_type == 0x01:
                            communication_type = 0x01  # Enable Rx, disable Tx
                        elif control_type == 0x02:
                            communication_type = 0x02  # Disable Rx, enable Tx
                        elif control_type == 0x03:
                            communication_type = 0x03  # Disable Rx and Tx
                        else:
                            logging.warning(f"Unknown subfunc for CommControl: {hex(control_type)}. Using 0x00.")
                            communication_type = 0x00
                        response = client.communication_control(control_type, communication_type)
                    else:
                        raise ValueError(f"Unsupported service: {service}")                           

                    response_time = datetime.now()
                    
                    if first_request_time is None:
                        first_request_time = request_time
                        last_response_time = response_time
                    
                    status = "Fail"
                    failure_reason = "-"
                    if response.positive:
                        actual = list(response.original_payload)
                        if actual[:len(expected_bytes)] == expected_bytes:
                            status = "Pass"
                            logging.info(f"{tc_id} {step_desc} -> PASS")
                        else:
                            failure_reason = f"Expected {expected_bytes}, got {actual}"
                            logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                    else:
                        failure_reason = f"NRC: {hex(response.code)}"
                        logging.warning(f"{tc_id} {step_desc} -> FAIL - {failure_reason}")
                except Exception as e:
                    response_time = datetime.now() 
                    status = "Fail"                        
                    failure_reason = str(e)
                    logging.error(f"{tc_id} {step_desc} -> EXCEPTION - {failure_reason}")

                oled.display_centered_text(f"{tc_id}\n{step_desc[:20]}\n{status}")
                time.sleep(2)
                
                relative_request_time = f"{(request_time - start_time).total_seconds():.6f}"
                relative_response_time = f"{(response_time - start_time).total_seconds():.6f}"
                
                report_entries.append({
                    "id": tc_id,
                    "timestamp": relative_request_time,
                    "response_timestamp": relative_response_time,
                    "description": step_desc,
                    "type": "Request Sent",
                    "status": status,
                    "failure_reason": failure_reason
                })

    run_end = datetime.now()
